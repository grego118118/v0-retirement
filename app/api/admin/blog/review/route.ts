/**
 * API Routes for Blog Content Review System
 * Massachusetts Retirement System - AI Content Management
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth/auth-config'
import { prisma } from '@/lib/prisma'
import { BlogPost, ContentReview } from '@/types/ai-blog'

/**
 * GET /api/admin/blog/review
 * Get posts pending review
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user || (session.user as any).role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const status = searchParams.get('status') || 'pending'
    const limit = parseInt(searchParams.get('limit') || '20')
    const offset = parseInt(searchParams.get('offset') || '0')

    // Get posts pending review
    const posts = await prisma.blogPost.findMany({
      where: {
        isAiGenerated: true,
        factCheckStatus: status as any,
        status: 'draft'
      },
      include: {
        categories: {
          include: {
            category: true
          }
        },
        reviews: {
          orderBy: {
            createdAt: 'desc'
          },
          take: 1
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      take: limit,
      skip: offset
    })

    // Transform to match our types
    const transformedPosts: BlogPost[] = posts.map(post => ({
      id: post.id,
      title: post.title,
      slug: post.slug,
      content: post.content,
      excerpt: post.excerpt || undefined,
      featured_image_url: post.featuredImageUrl || undefined,
      author_id: post.authorId || undefined,
      published_at: post.publishedAt?.toISOString() || undefined,
      created_at: post.createdAt.toISOString(),
      updated_at: post.updatedAt.toISOString(),
      status: post.status as 'draft' | 'published' | 'archived',
      view_count: post.viewCount,
      seo_title: post.seoTitle || undefined,
      seo_description: post.seoDescription || undefined,
      seo_keywords: post.seoKeywords || undefined,
      is_ai_generated: post.isAiGenerated,
      ai_model_used: post.aiModelUsed || undefined,
      ai_generation_prompt: post.aiGenerationPrompt || undefined,
      ai_generation_cost: post.aiGenerationCost ? parseFloat(post.aiGenerationCost.toString()) : undefined,
      content_quality_score: post.contentQualityScore || undefined,
      fact_check_status: post.factCheckStatus as 'pending' | 'approved' | 'needs_review' | 'rejected',
      scheduled_publish_at: post.scheduledPublishAt?.toISOString() || undefined,
      auto_generated_tags: post.autoGeneratedTags || undefined,
      internal_links_added: post.internalLinksAdded,
      seo_optimized: post.seoOptimized
    }))

    return NextResponse.json({
      posts: transformedPosts,
      total: posts.length,
      hasMore: posts.length === limit
    })

  } catch (error) {
    console.error('Error fetching posts for review:', error)
    return NextResponse.json(
      { error: 'Failed to fetch posts for review' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/admin/blog/review
 * Submit a content review
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user || (session.user as any).role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      post_id,
      review_status,
      review_notes,
      content_quality_rating,
      fact_check_completed = false,
      seo_check_completed = false,
      suggested_changes
    } = body

    // Validate required fields
    if (!post_id || !review_status) {
      return NextResponse.json(
        { error: 'Missing required fields: post_id, review_status' },
        { status: 400 }
      )
    }

    // Validate review status
    const validStatuses = ['pending', 'approved', 'needs_changes', 'rejected']
    if (!validStatuses.includes(review_status)) {
      return NextResponse.json(
        { error: 'Invalid review status' },
        { status: 400 }
      )
    }

    // Start transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create content review record
      const review = await tx.contentReview.create({
        data: {
          postId: post_id,
          reviewerId: session.user.id,
          reviewStatus: review_status,
          reviewNotes: review_notes,
          factCheckCompleted: fact_check_completed,
          seoCheckCompleted: seo_check_completed,
          contentQualityRating: content_quality_rating,
          suggestedChanges: suggested_changes,
          reviewedAt: new Date()
        }
      })

      // Update blog post status based on review
      let updateData: any = {
        factCheckStatus: review_status,
        updatedAt: new Date()
      }

      // If approved, prepare for publishing
      if (review_status === 'approved') {
        updateData.status = 'published'
        updateData.publishedAt = new Date()

        // Mark as fact-checked and SEO optimized if not already
        if (fact_check_completed) {
          updateData.factCheckStatus = 'approved'
        }
        if (seo_check_completed) {
          updateData.seoOptimized = true
        }
      }

      // If rejected, mark as archived
      if (review_status === 'rejected') {
        updateData.status = 'archived'
      }

      const updatedPost = await tx.blogPost.update({
        where: { id: post_id },
        data: updateData
      })

      return { review, updatedPost }
    })

    // Log the review action
    console.log(`Content review submitted by ${session.user.email}:`, {
      post_id,
      review_status,
      reviewer_id: session.user.id
    })

    // Trigger n8n workflow webhook (if configured)
    try {
      const n8nWebhookUrl = process.env.N8N_WEBHOOK_URL
      if (n8nWebhookUrl) {
        await fetch(n8nWebhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'review_submitted',
            post_id,
            review_status,
            review_notes,
            content_quality_rating,
            reviewer_name: session.user.name || session.user.email,
            post_title: result.updatedPost.title,
            suggested_changes,
            timestamp: new Date().toISOString()
          })
        })
      }
    } catch (error) {
      console.warn('Failed to trigger n8n webhook:', error)
      // Don't fail the review if webhook fails
    }

    return NextResponse.json({
      success: true,
      review: result.review,
      message: `Post ${review_status === 'approved' ? 'approved and published' : review_status}`
    })

  } catch (error) {
    console.error('Error submitting content review:', error)
    return NextResponse.json(
      { error: 'Failed to submit content review' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/admin/blog/review/[id]
 * Update an existing review
 */
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user || (session.user as any).role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { searchParams } = new URL(request.url)
    const reviewId = searchParams.get('id')

    if (!reviewId) {
      return NextResponse.json(
        { error: 'Review ID is required' },
        { status: 400 }
      )
    }

    const {
      review_status,
      review_notes,
      content_quality_rating,
      fact_check_completed,
      seo_check_completed,
      suggested_changes
    } = body

    // Update the review
    const updatedReview = await prisma.contentReview.update({
      where: { id: reviewId },
      data: {
        reviewStatus: review_status,
        reviewNotes: review_notes,
        contentQualityRating: content_quality_rating,
        factCheckCompleted: fact_check_completed,
        seoCheckCompleted: seo_check_completed,
        suggestedChanges: suggested_changes,
        reviewedAt: new Date()
      }
    })

    return NextResponse.json({
      success: true,
      review: updatedReview,
      message: 'Review updated successfully'
    })

  } catch (error) {
    console.error('Error updating content review:', error)
    return NextResponse.json(
      { error: 'Failed to update content review' },
      { status: 500 }
    )
  }
}


